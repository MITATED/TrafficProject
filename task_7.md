## Определение функции:
> Имеется определение функции:
> def f(t, x={}):
>  ...
> Есть ли здесь проблема? Если есть, то в чём?

При обьявлении функции таким образом
```python
>>> def f(t, x={}):
...
```
могут возникнуть проблемы.
При передачи аргументов функции мы передаем не название переменной, а ее место в памяти:
```python
>>> a = 5
>>> print(id(a))
39002360
>>>
>>> def x(a):
... 	print(id(a))
>>> x(a)
39002360
```
Если в фунции есть необязательный аргумент и он не передается при вызове, то инициализация места для этой переменной происходит в момент первого вызова функции:
```python
>>> def x(a = 5):
... 	print(id(a))
>>> x()
12853496
>>> x()
12853496
```
Как видим идентификатор переменной `a` не изменился при повторном вызове функции, с этого следует что по завершению работы функции ее переменные все-равно остаются в памяти. 
Проблемы могут возникнуть если в дефолтное значение аргумента передавать mutable обьект и изменять его в функции:
```python
>>> def x(a = {1: 2, 3: 4}):
... 	print(a)
... 	print(id(a))
... 	a[5] = 6
>>> x()
{1: 2, 3: 4}
140126154511536
>>> x()
{1: 2, 3: 4, 5: 6}
140126154511536
```
То есть при повторном вызове функции ячейка памяти, которая присваевыется переменной "a" не изменилась и не инициализировалась заново.
Из-за этого могут возникнуть проблемы, так что лучше избегать передачи mutable обьектов в дефолтное значение. Это, конечно, можно использовать в коде, но не желательно. Так как это противоречит "The Zen of Python" - "Явное лучше чем неявное".

